package io.github.lancelothuxi.mock.functions;

import java.io.File;
import java.io.FileFilter;
import java.net.JarURLConnection;
import java.net.URL;
import java.net.URLDecoder;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.List;
import java.util.jar.JarEntry;
import java.util.jar.JarFile;

public final class ClassFinder {

  private static final String CLASS_SUFFIX = ".class";

  public static List<String> getClasssFromPackage(String pack) {
    List<String> classes = new ArrayList<>();

    // 是否循环搜索子包
    boolean recursive = true;

    // 包名字
    String packageName = pack;
    // 包名对应的路径名称
    String packageDirName = packageName.replace('.', '/');

    Enumeration<URL> dirs;

    try {
      dirs = Thread.currentThread().getContextClassLoader().getResources(packageDirName);
      while (dirs.hasMoreElements()) {
        URL url = dirs.nextElement();

        String protocol = url.getProtocol();

        if ("file".equals(protocol)) {
          String filePath = URLDecoder.decode(url.getFile(), "UTF-8");
          findClassInPackageByFile(packageName, filePath, recursive, classes);
        } else if ("jar".equals(protocol)) {
          JarFile jarFile = null;
          jarFile = ((JarURLConnection) url.openConnection()).getJarFile();
          getAllClassNameByJar(jarFile, packageName, recursive, classes);
        }
      }

    } catch (Exception e) {
      e.printStackTrace();
    }

    return classes;
  }

  public static void findClassInPackageByFile(
      String packageName, String filePath, final boolean recursive, List<String> classes) {
    File dir = new File(filePath);
    if (!dir.exists() || !dir.isDirectory()) {
      return;
    }
    // 在给定的目录下找到所有的文件，并且进行条件过滤
    File[] dirFiles =
        dir.listFiles(
            new FileFilter() {

              @Override
              public boolean accept(File file) {
                boolean acceptDir = recursive && file.isDirectory(); // 接受dir目录
                boolean acceptClass = file.getName().endsWith("class"); // 接受class文件
                return acceptDir || acceptClass;
              }
            });

    for (File file : dirFiles) {
      if (file.isDirectory()) {
        findClassInPackageByFile(
            packageName + "." + file.getName(), file.getAbsolutePath(), recursive, classes);
      } else {
        String className = file.getName().substring(0, file.getName().length() - 6);
        try {
          classes.add(packageName + "." + className);
        } catch (Exception e) {
          e.printStackTrace();
        }
      }
    }
  }

  private static void getAllClassNameByJar(
      JarFile jarFile, String packageName, boolean flag, List<String> classes) {
    Enumeration<JarEntry> entries = jarFile.entries();
    while (entries.hasMoreElements()) {
      JarEntry jarEntry = entries.nextElement();
      String name = jarEntry.getName();
      // 判断是不是class文件
      if (name.endsWith(CLASS_SUFFIX)) {
        name = name.replace(CLASS_SUFFIX, "").replace("/", ".");
        if (flag) {
          // 如果要子包的文件,那么就只要开头相同且不是内部类就ok
          if (name.startsWith(packageName) && -1 == name.indexOf("$")) {
            classes.add(name);
          }
        } else {
          // 如果不要子包的文件,那么就必须保证最后一个"."之前的字符串和包名一样且不是内部类
          if (packageName.equals(name.substring(0, name.lastIndexOf(".")))
              && -1 == name.indexOf("$")) {
            classes.add(name);
          }
        }
      }
    }
  }
}
